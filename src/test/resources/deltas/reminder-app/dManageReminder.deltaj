delta dManageReminder {
	adds {
		package br.unb.cic.reminders;

		import android.app.Activity;
		import android.app.FragmentTransaction;
		import android.content.Intent;
		import android.os.Bundle;
		import android.view.Menu;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import br.unb.cic.reminders.view.AddReminderActivity;
		import br.unb.cic.reminders.view.ReminderListFragment;
		import br.unb.cic.reminders2.R;

		public class ReminderMainActivity extends Activity {

			private static String TAG = "Reminder";
			private FragmentTransaction ft;
			private ReminderListFragment listReminderFragment;

			/**
			 * Called when the activity is first created.
			 *
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminders_main_activity);
				createUI();
			}

			/**
			 * Creates the User Interface. Creates the ListFragment.
			 */
			private void createUI() {
				ft = getFragmentManager().beginTransaction();
				listReminderFragment = new ReminderListFragment();
				ft.add(R.id.listReminders, listReminderFragment);
				ft.commit();
			}

			/**
			 * Create Options Menu. Creates the buttons on the ActionBar.
			 */
			@Override
			public boolean onCreateOptionsMenu(Menu menu) {
				MenuInflater inflater = getMenuInflater();
				inflater.inflate(R.menu.action_bar_menu, menu);
				return true;
			}

			/**
			 * Switch between the buttons in the options menu.
			 */
			@Override
			public boolean onOptionsItemSelected(MenuItem item) {
				switch (item.getItemId()) {
				case R.id.menu_addReminder:
					// app icon in action bar clicked; go home
					Intent reminderIntent = new Intent(getApplicationContext(), AddReminderActivity.class);
					startActivity(reminderIntent);
					return true;
				default:
					return super.onOptionsItemSelected(item);
				}
			}

		}
	}
	adds {
		package util;

		import java.text.ParseException;
		import java.text.SimpleDateFormat;
		import java.util.Date;
		import java.util.Locale;

		public class DateFormat {
			/*
			 * Static function that formats the database readable date into an object of
			 * type Date
			 */
			public static Date dateFormater(String dateUnformated) throws ParseException {
				SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-yyyy HH:mm", Locale.getDefault());
				return sdf.parse(dateUnformated);
			}

		}
	}
	adds {
		package util;

		import android.text.Editable;
		import android.text.TextWatcher;
		import android.widget.EditText;

		/**
		 * Class used to mask the input of editTexts. For example for date:YYYY-MM-DD.
		 */
		public abstract class Mask {

			/**
			 * Unmasks a String;
			 */
			public static String unmask(String str) {
				return str.replaceAll("[:]", "").replaceAll("[.]", "").replaceAll("[-]", "").replaceAll("[/]", "")
						.replaceAll("[(]", "").replaceAll("[)]", "");
			}

			/**
			 * Inserts one mask to an EditText.
			 *
			 * @param String
			 *            mask, EditText editText, the string is used to pass the format
			 *            of the mask through a string, for example "##-##-####" and the
			 *            EditText that will be watched and changed based in the mask.
			 */
			public static TextWatcher insert(final String mask, final EditText ediTxt) {
				return new TextWatcher() {
					boolean isUpdating;
					String old = "";

					public void onTextChanged(CharSequence s, int start, int before, int count) {
						String str = Mask.unmask(s.toString());
						String txt = "";
						if (isUpdating) {
							old = str;
							isUpdating = false;
							return;
						}
						int i = 0;
						boolean done = false;
						for (char m : mask.toCharArray()) {
							if (!done && m != '#' && str.length() > old.length()) {
								txt += m;
							} else if (!done && i < str.length()) {
								txt += str.charAt(i);
								i++;
							} else {
								done = true;
							}
						}
						isUpdating = true;
						ediTxt.setText(txt);
						ediTxt.setSelection(txt.length());
					}

					public void beforeTextChanged(CharSequence s, int start, int count, int after) {
					}

					public void afterTextChanged(Editable s) {
					}
				};
			}

		}
	}
	adds {
		package util;

		public class Patterns {

			// TODO: Fix TEXT_PATTERN to allow "." in the middle of text and not only in
			// the end of the sentence.
			public static final String TEXT_PATTERN = "[^.!?\\s][^.!?]*(?:[.!?](?![']?\\s|$)[^.!?]*)*[.!?]?[']?(?=\\s|$)";

			public static final String DATE_PATTERN = "(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\\d\\d";

			public static final String HOUR_PATTERN = "([01]?[0-9]|2[0-3]):[0-5][0-9]";
		}
	}
	adds {
		package util;

		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ListAdapter;
		import android.widget.ListView;

		/**
		 * Created to give some general use functions.
		 *
		 * @author rafaelsimao
		 */

		public class Utility {

			/**
			 * Rearrange the size of a ListView to its content size.
			 *
			 * @param listView
			 */
			public static void setListViewHeightBasedOnChildren(ListView listView) {
				ListAdapter listAdapter = listView.getAdapter();
				if (listAdapter == null) {
					// pre-condition
					return;
				}

				int totalHeight = 0;
				for (int i = 0; i < listAdapter.getCount(); i++) {
					View listItem = listAdapter.getView(i, null, listView);
					listItem.measure(0, 0);
					totalHeight += listItem.getMeasuredHeight();
				}

				ViewGroup.LayoutParams params = listView.getLayoutParams();
				params.height = totalHeight + (listView.getDividerHeight()*(listAdapter.getCount() - 1));
				listView.setLayoutParams(params);
			}

		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;

		import br.unb.cic.framework.persistence.DBTypes;

		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface Column {
			String column();

			boolean primaryKey() default false;

			DBTypes type();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;

		/**
		 * An interface to declare entity classes.
		 *
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.TYPE)
		public @interface Entity {
			String table();
		}
	}
	adds {
		package br.unb.cic.framework.persistence.annotations;

		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;

		/**
		 * Used to map an attribute as a foreign key in the database.
		 *
		 * @author rbonifacio
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.FIELD)
		public @interface ForeignKey {
			String mappedBy();
		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		/**
		 * Use to signal database exceptions.
		 *
		 * @author rbonifacio.
		 */
		public class DBException extends Exception {

			private static final long serialVersionUID = 1L;

		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		/**
		 * Exception that is thrown when an invalid Entity is identified by the
		 * persistence framework.
		 *
		 * @author rbonifacio
		 */
		public class DBInvalidEntityException extends Exception {

			private static final long serialVersionUID = 1L;

			/**
			 * Constructor
			 *
			 * @param e
			 *            the invalid entity
			 */
			public DBInvalidEntityException(Object e) {
				super(e.getClass().getCanonicalName() + "is not a valid entity according to the persistence framework.");
			}
		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		/**
		 * An enumeration with the valid types that can be mapped into the database
		 * columns.
		 *
		 * @author rbonifacio
		 */
		public enum DBTypes {
			INT, LONG, TEXT;
		}
	}
	adds {
		package br.unb.cic.framework.persistence;

		import java.lang.reflect.Field;
		import java.lang.reflect.Method;
		import java.util.ArrayList;
		import java.util.List;

		import android.content.ContentValues;
		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteDatabase;
		import android.util.Log;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		import br.unb.cic.framework.persistence.annotations.ForeignKey;
		import br.unb.cic.reminders.model.db.DBHelper;

		/**
		 * A generic DAO class.
		 *
		 * @author rbonifacio
		 */
		public class GenericDAO<T> {

			protected Context context;
			protected SQLiteDatabase db;
			protected DBHelper dbHelper;

			private static final String DATABASE_NAME = "ReminderDB";
			private static final int DATABASE_VERSION = 7;

			/**
			 * Constructor of GenericDAO.
			 *
			 * @param c
			 *            the application context.
			 */
			public GenericDAO(Context c) {
				context = c;
				dbHelper = new DBHelper(context, DATABASE_NAME, null, DATABASE_VERSION);
			}

			/**
			 * Save a specific entity into the database.
			 *
			 * @param entity
			 *            that will be stored.
			 *
			 * @return the Id of the entity in the database.
			 */
			protected Long persist(T entity) throws DBInvalidEntityException, DBException {
				try {
					db = dbHelper.getWritableDatabase();

					ContentValues values = new ContentValues();

					if (!entity.getClass().isAnnotationPresent(Entity.class)) {
						throw new DBInvalidEntityException(entity);
					}

					String tableName = entity.getClass().getAnnotation(Entity.class).table();

					boolean update = false;
					String updateWhereClause = null;

					for (Field f : entity.getClass().getDeclaredFields()) {
						if (f.isAnnotationPresent(Column.class)) {
							String column = f.getAnnotation(Column.class).column();
							boolean pk = f.getAnnotation(Column.class).primaryKey();

							String methodName = getMethod(f.getName());
							Class args[] = {};
							Method m = entity.getClass().getDeclaredMethod(methodName, args);

							Object value = m.invoke(entity, args);

							// in the cases where the field is a related object, mapped
							// by a FK, a specific
							// behavior is necessary, since we need to get the value of
							// the
							// primary key of the related object.
							if (f.isAnnotationPresent(ForeignKey.class)) {
								String fk = f.getAnnotation(ForeignKey.class).mappedBy();
								methodName = getMethod(fk);

								m = value.getClass().getDeclaredMethod(methodName, args);

								value = m.invoke(value, args);
							}
							if (value != null) {
								values.put(column, value.toString());
							} else {
								values.putNull(column);
							}
							if (pk && value != null) {
								update = true;
								updateWhereClause = column + " = " + value.toString();
							}
						}
					}
					Long id = null;
					db.beginTransaction();
					if (!update) {
						id = db.insert(tableName, null, values);
					} else {
						db.update(tableName, values, updateWhereClause, null);
					}
					db.setTransactionSuccessful();
					return id;
				} catch (Exception e) {
					e.printStackTrace();
					throw new DBException();
				} finally {
					if (db.inTransaction()) {
						db.endTransaction();
					}
					db.close();
					dbHelper.close();
				}
			}

			public T cursorToEntity(Cursor cursor, Class<T> clasz) throws DBInvalidEntityException, Exception {
				if (!clasz.isAnnotationPresent(Entity.class)) {
					throw new DBInvalidEntityException(clasz);
				}

				T entity = clasz.newInstance();

				for (Field f : declaredFields(clasz)) {
					Class args[] = { f.getType() };

					if (!f.isAnnotationPresent(ForeignKey.class)) {
						Method m = entity.getClass().getDeclaredMethod(setMethod(f.getName()), args);

						m.invoke(entity, fieldValueFromCursor(cursor, f));
					} else {

					}
				}

				return entity;
			}

			private Object fieldValueFromCursor(Cursor cursor, Field f) {
				String column = f.getAnnotation(Column.class).column();
				DBTypes type = f.getAnnotation(Column.class).type();

				switch (type) {
				case INT:
					return cursor.getInt(cursor.getColumnIndex(column));
				case LONG:
					return cursor.getLong(cursor.getColumnIndex(column));
				case TEXT:
					return cursor.getString(cursor.getColumnIndex(column));
				default:
					return null;
				}
			}

			private List<Field> declaredFields(Class<T> clasz) {
				List<Field> fields = new ArrayList<Field>();
				for (Field f : clasz.getDeclaredFields()) {
					if (f.isAnnotationPresent(Column.class)) {
						fields.add(f);
					}
				}
				return fields;
			}

			private String setMethod(String field) {
				return "set" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}

			private String getMethod(String field) {
				return "get" + field.substring(0, 1).toUpperCase() + field.substring(1);
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;

		public class InvalidTextException extends InvalidFormatException {

			private static final long serialVersionUID = 7998188562654167391L;

			public InvalidTextException(Object o) {
				super("This text " + o);
			}

		}
	}
	adds {
		package br.unb.cic.reminders.model;

		/**
		 * Exception that might be used to report situations where an invalid format was
		 * detected. For instance, we throw an instance of this exception when we try to
		 * set a date as a string that does not match the expected date format.
		 *
		 * @author rbonifacio
		 */
		public class InvalidFormatException extends RuntimeException {

			private static final long serialVersionUID = 2850584940310533216L;

			/**
			 * InvalidFormatException constructor.
			 *
			 * @param o
			 *            An object that does not match an expected format.
			 */
			public InvalidFormatException(Object o) {
				super(o + " is in the wrong format");
			}
		}
	}
	adds {
		package br.unb.cic.reminders.model;

		public class InvalidDateException extends InvalidFormatException {

			private static final long serialVersionUID = 7194191177254259925L;

			public InvalidDateException(Object o) {
				super("This date " + o);
			}

		}
	}
	adds {
		package br.unb.cic.reminders.model.db;

		import android.content.Context;
		import android.database.sqlite.SQLiteDatabase;
		import android.database.sqlite.SQLiteDatabase.CursorFactory;
		import android.database.sqlite.SQLiteException;
		import android.database.sqlite.SQLiteOpenHelper;
		import android.util.Log;

		public class DBHelper extends SQLiteOpenHelper {

			public DBHelper(Context context, String name, CursorFactory factory, int version) {
				super(context, name, factory, version);
			}

			@Override
			public void onOpen(SQLiteDatabase db) {
				db.execSQL("PRAGMA foreign_keys=ON;");
				super.onOpen(db);
			}

			@Override
			public void onCreate(SQLiteDatabase db) {
				try {
					for (String sql : DBConstants.CREATE_TABLE_STATEMENTS) {
						Log.i(DBHelper.class.getCanonicalName(), sql);
						db.execSQL(sql);
					}
				} catch (SQLiteException e) {
					Log.v(DBHelper.class.getName(), e.getMessage());
				}
			}

			@Override
			public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
				try {
					for (String sql : DBConstants.DROP_TABLE_STATEMENTS) {
						db.execSQL(sql);
					}
					onCreate(db);
				} catch (SQLiteException e) {
					Log.v(DBHelper.class.getName(), e.getMessage());
				}
			}

		}
	}
	adds {
		package br.unb.cic.reminders.model.db;

		import java.util.List;

		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.model.Reminder;

		/**
		 * A Data Access Object for handling the persistence mechanism of reminders.
		 *
		 * @author rbonifacio
		 */
		public interface ReminderDAO {

			/**
			 * Save a reminder in the reminders database.
			 *
			 * @param reminder
			 *            - the reminder that will be stored.
			 * @return the reminder id.
			 */
			public Long saveReminder(Reminder r) throws DBException;

			/**
			 * List all reminders of the Reminders database.
			 *
			 * @return list of registered reminders.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public List<Reminder> listReminders() throws DBException;

			/**
			 * Update a given reminder from the database
			 *
			 * @param reminder
			 *            the reminder that will be updated from the database. it
			 *            contains all fields with the new values and the id of the
			 *            reminder to be updated.
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void updateReminder(Reminder reminder) throws DBException;

			/**
			 * Delete a given reminder from the database
			 *
			 * @param reminder
			 *            the reminder that will be dropped from the database
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void deleteReminder(Reminder reminder) throws DBException;

			/**
			 * Persist a given reminder from the database
			 *
			 * @param reminder
			 *            the reminder that will be persisted in the database
			 * @throws DBException
			 *             if anything goes wrong with the database query
			 */
			public void persistReminder(Reminder reminder) throws DBException;
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;

		import java.util.ArrayList;
		import java.util.List;

		import android.content.Context;
		import android.database.Cursor;
		import android.database.sqlite.SQLiteException;
		import android.util.Log;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.framework.persistence.DBInvalidEntityException;
		import br.unb.cic.framework.persistence.GenericDAO;
		import br.unb.cic.reminders.model.Reminder;

		/**
		 * A default implementation of the @see {@link ReminderDAO} interface.
		 *
		 * @author positivo
		 *
		 */
		public class DefaultReminderDAO extends GenericDAO<Reminder> implements ReminderDAO {

			public DefaultReminderDAO(Context c) {
				super(c);
			}

			/**
			 * @see ReminderDAO#saveReminder(Reminder reminder)
			 */
			public Long saveReminder(Reminder r) throws DBException {
				try {
					return persist(r);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				}
			}

			/**
			 * @see ReminderDAO#saveReminder(Reminder)
			 */
			public List<Reminder> listReminders() throws DBException {
				try {
					db = dbHelper.getReadableDatabase();
					Cursor cursor = db.rawQuery(DBConstants.SELECT_REMINDERS, null);

					return remindersFromCursor(cursor);
				} catch (Exception e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}

			/**
			 * TODO: I guess that this note does not make sense any more.
			 *
			 * @see ReminderDAO#updateReminder(Reminder reminder) As it was asked on
			 *      iceScrum, the update use the persist method after removing the given
			 *      reminder. If this was what was asked then it is done, otherwise the
			 *      persist method can be upgraded to support the update functionality
			 *      (if it isn't already implemented. I guess it isn't) later by
			 *      refactoring it.
			 */
			public void updateReminder(Reminder reminder) throws DBException {
				try {
					persist(reminder);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}

			/**
			 * @see ReminderDAO#deleteReminder(Reminder reminder)
			 */
			public void deleteReminder(Reminder reminder) throws DBException {
				try {
					db = dbHelper.getWritableDatabase();
					db.delete(DBConstants.REMINDER_TABLE, DBConstants.REMINDER_PK_COLUMN + "=" + reminder.getId(), null);
				} catch (SQLiteException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}

			public void persistReminder(Reminder reminder) throws DBException {
				try {
					persist(reminder);
				} catch (DBInvalidEntityException e) {
					throw new DBException();
				} finally {
					db.close();
					dbHelper.close();
				}
			}

			/*
			 * Transform a cursor into a Reminder
			 */
			private Reminder cursorToReminder(Cursor cursor) throws DBException {
				Long pk = cursor.getLong(cursor.getColumnIndex(DBConstants.REMINDER_PK_COLUMN));
				String text = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_TEXT_COLUMN));
				String details = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DETAILS_COLUMN));
				int done = cursor.getInt(cursor.getColumnIndex(DBConstants.REMINDER_DONE_COLUMN));

				Reminder reminder = createReminderCursor(cursor);

				reminder.setText(text);
				reminder.setDetails(details);
				reminder.setId(pk);
				reminder.setDone(done);
				return reminder;
			}

			private Reminder createReminderCursor(Cursor cursor) throws DBException {
				Reminder reminder = new Reminder();
				String date = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_DATE_COLUMN));
				String hour = cursor.getString(cursor.getColumnIndex(DBConstants.REMINDER_HOUR_COLUMN));
				reminder.setDate(date);
				reminder.setHour(hour);
				return reminder;
			}

			/*
			 * Iterates over a cursor in order to build a list of reminders.
			 */
			private List<Reminder> remindersFromCursor(Cursor cursor) throws DBException {
				List<Reminder> reminders = new ArrayList<Reminder>();

				if (cursor.moveToFirst()) {
					do {
						Reminder reminder = cursorToReminder(cursor);
						reminders.add(reminder);
					} while (cursor.moveToNext());
				}
				cursor.close();
				return reminders;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.Calendar;

		import android.app.DatePickerDialog;
		import android.app.Dialog;
		import android.app.DialogFragment;
		import android.content.DialogInterface;
		import android.os.Bundle;
		import android.widget.ArrayAdapter;
		import android.widget.DatePicker;
		import android.widget.Spinner;

		class DatePickerDialogFragment extends DialogFragment implements DatePickerDialog.OnDateSetListener {

			private Calendar date;
			private Spinner spinnerDate;

			private int pYear;
			private int pDay;
			private int pMonth;

			public DatePickerDialogFragment(Calendar date, Spinner spinnerDate) {
				this.date = date;
				this.spinnerDate = spinnerDate;
			}

			@Override
			public Dialog onCreateDialog(Bundle savedInstanceState) {
				// Use the current date as the default date in the picker
				int year = date.get(Calendar.YEAR);
				int month = date.get(Calendar.MONTH);
				int day = date.get(Calendar.DAY_OF_MONTH);

				// Create a new instance of DatePickerDialog and return it
				return new DatePickerDialog(getActivity(), this, year, month, day);
			}

			@SuppressWarnings("unchecked")
			@Override
			public void onDismiss(DialogInterface dialog) {
				date.set(pYear, pMonth, pDay);
				String sDate = Integer.toString(pDay) + "-" + Integer.toString(pMonth + 1) + "-" + Integer.toString(pYear);

				ArrayAdapter<String> adapter = (ArrayAdapter<String>) spinnerDate.getAdapter();

				/* DO NOT DELETE THESE COMMENTS! (Alexandre) */
				/* Maybe we need it next Sprint. */
				// if(adapter.getCount() > 2) {
				// adapter.remove(adapter.getItem(2));
				// }
				adapter.add(sDate);
				spinnerDate.setSelection(2);

				super.onDismiss(dialog);
			}

			public void onDateSet(DatePicker view, int year, int month, int day) {
				pYear = year;
				pDay = day;
				pMonth = month;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import br.unb.cic.reminders.controller.ReminderFilter;

		/**
		 * Interface used to receive a category list changing notificaton.
		 *
		 * @author rbonifacio
		 */
		public interface FiltersListChangeListener {

			public void onSelectedFilterChanged(ReminderFilter filter);

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import br.unb.cic.reminders.model.InvalidFormatException;

		public class InvalidHourException extends InvalidFormatException {

			private static final long serialVersionUID = 8341230773647025695L;

			public InvalidHourException(Object o) {
				super("This hour " + o);
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.Arrays;
		import java.util.List;

		import util.Mask;
		import android.app.Activity;
		import android.content.Intent;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.View;
		import android.widget.AdapterView;
		import android.widget.AdapterView.OnItemSelectedListener;
		import android.widget.ArrayAdapter;
		import android.widget.Button;
		import android.widget.EditText;
		import android.widget.Spinner;
		import android.widget.Toast;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.InvalidDateException;
		import br.unb.cic.reminders.model.InvalidFormatException;
		import br.unb.cic.reminders.model.InvalidTextException;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;

		/**
		 * Activity used to add reminders (local or from external applications).
		 *
		 * If an external app wants to add a reminder, it must pass all the
		 * corresponding reminders' attributes to the intent which starts this activity.
		 * They are: "text", "category", "date" and "hour".
		 */

		public class ReminderAddActivity extends Activity {

			private EditText edtReminder, edtDetails, edtDate, edtHour; // ,
																		// edtPriority,
																		// edtCategory;

			private Button btnSave, btnCancel;

			private boolean editingReminder;
			private Long previewReminderId;

			@Override
			public void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminder_add);

				/*
				 * Checks whether reminder's data exists in the intent, that is, verify
				 * if this activity was started by an external app.
				 */
				Reminder existingReminder = getReminderFromIntent();

				if (existingReminder == null) {
					// Used to get the informations of the Reminder being edited:
					editingReminder = true;
					Reminder editReminder = getExistingReminder();
					initialize(editReminder);
				} else {
					/*
					 * Initialize the view, optionally filling the fields with content
					 * sent by another app. This is the ONLY purpose of the object
					 * "existingReminder".
					 */
					editingReminder = false;
					initialize(existingReminder);
				}

				configureActionListener();

			}

			private void configureActionListener() {
				addListenerToBtnSave();
				addListenerToBtnCancel();
			}

			private void addListenerToBtnSave() {
				btnSave.setOnClickListener(new Button.OnClickListener() {
					public void onClick(View v) {
						try {
							Reminder reminder = createReminder();
							if (editingReminder) {
								reminder.setId(previewReminderId);
								Controller.instance(getApplicationContext()).updateReminder(reminder);
							} else {
								Controller.instance(getApplicationContext()).addReminder(reminder);
							}
							finish(); // Kills the activity
						} catch (Exception e) {
							Log.e("ReminderAddActivity", e.getMessage());
							e.printStackTrace();
						}
					}

				});
			}

			private void addListenerToBtnCancel() {
				btnCancel.setOnClickListener(new Button.OnClickListener() {
					public void onClick(View v) {
						finish();
					}
				});
			}

			/*
			 * Just an auxiliary method to create reminders from the UI data.
			 *
			 * @return a new reminder.
			 */
			private Reminder createReminder() {
				/*
				 * Since view's not passing all the information yet (priority ...), we
				 * instantiate a reminder initially passing only "text" and "date".
				 */
				Reminder reminder = new Reminder();
				try {
					reminder = createReminderAux();
					reminder.setText(edtReminder.getText().toString());
					reminder.setDetails(edtDetails.getText().toString());
				} catch (InvalidTextException e) {
					Toast.makeText(getApplicationContext(), "Invalid text.", Toast.LENGTH_SHORT).show();
				} catch (InvalidDateException e) {
					Toast.makeText(getApplicationContext(), "Invalid date.", Toast.LENGTH_SHORT).show();
				} catch (InvalidHourException e) {
					Toast.makeText(getApplicationContext(), "Invalid time.", Toast.LENGTH_SHORT).show();
				}
				return reminder;
			}

			private Reminder createReminderAux() {
				Reminder reminder = new Reminder();
				reminder.setDate(edtDate.getText().toString());
				reminder.setHour(edtHour.getText().toString());
				return reminder;
			}

			/*
			 * This method is used to verify if it is an editing call and if it is gets
			 * the information of the reminder wanted to be updated and its id that will
			 * be used latter to update the Reminder from the Intent.
			 */
			private Reminder getExistingReminder() {
				Reminder reminder = null;

				Intent intent = getIntent();
				String action = intent.getAction();
				String type = intent.getType();

				// Gets the information from the intent if it is an edit call
				if (Intent.ACTION_SEND.equals(action) && "text/plain".equals(type)) {
					previewReminderId = intent.getLongExtra("id", 0);
					String text = intent.getStringExtra("text");

					reminder = createReminderExisting(intent);
					reminder.setText(text);
					reminder.setId(previewReminderId);
				}

				return reminder;
			}

			private Reminder createReminderExisting(Intent intent) {
				Reminder reminder = new Reminder();
				String date = intent.getStringExtra("date");
				String hour = intent.getStringExtra("hour");
				reminder.setDate(date);
				reminder.setHour(hour);
				return reminder;
			}

			/*
			 * Integration code (with another apps).
			 *
			 * The code below handles incoming requests from external apps which wants
			 * to add a reminder (eg.: Users may want to add a reminder for a TV program
			 * which they're seeing in GuiaTV app).
			 */
			private Reminder getReminderFromIntent() {
				Intent intent = getIntent();
				String action = intent.getAction();
				String type = intent.getType();

				/*
				 * External apps which wants to share content with "Lembretes" must
				 * follow the protocol described by the "if" below, that is, they must
				 * instantiate an intent and set:
				 *
				 * ACTION as "br.com.positivo.reminders.ADD_REMINDER"; MIME as
				 * "text/plain";
				 *
				 * and pass the contents through "putExtra" in the following fields:
				 * "text", "details", "category", "date", "hour" and "priority".
				 */
				if ("br.com.positivo.reminders.ADD_REMINDER".equals(action) && "text/plain".equals(type)) {
					try {
						String text = intent.getStringExtra("text");
						String details = intent.getStringExtra("details");

						/*
						 * Code below just validates the data supplied, since validation
						 * code is implemented in setter methods.
						 */

						// Would we better apply validations here?
						Reminder reminder = createReminderIntent(intent);
						reminder.setText(text);
						reminder.setDetails(details);
						/*
						 * Upon here, all validations were applied and we have a valid
						 * reminder. So, we return it.
						 */
						return reminder;
					} catch (InvalidFormatException e) {
						/*
						 * What would be better? 1. Return user to the calling activity.
						 * 2. Show an empty reminder's add form (implemented now).
						 */
					}
				}
				/*
				 * If this activity was not started from an external app or a valid
				 * reminder could not be derived, we simply return "null".
				 */
				return null;
			}

			private Reminder createReminderIntent(Intent intent) {
				Reminder reminder = new Reminder();
				String date = intent.getStringExtra("date");
				String hour = intent.getStringExtra("hour");
				reminder.setDate(date);
				reminder.setHour(hour);
				return reminder;
			}

			/*
			 * Initializes the view.
			 *
			 * This method just initializes the form for adding a new reminder. If a
			 * reminder object is supplied, "initialize" pre-populates the form with
			 * that content.
			 */
			private void initialize(Reminder reminder) {
				try {
					edtReminder = (EditText) findViewById(R.id.edtReminder);

					edtDetails = (EditText) findViewById(R.id.edtDetails);

					// edtDate = (EditText) findViewById(R.id.edtDate);
					// edtDate.addTextChangedListener(Mask.insert("##-##-####",
					// edtDate));

					// edtHour = (EditText) findViewById(R.id.edtHour);
					// edtHour.addTextChangedListener(Mask.insert("##:##", edtHour));

					if (reminder != null) {
						updateFieldsFromReminder(reminder);
					}

					btnSave = (Button) findViewById(R.id.btnSave);
					btnCancel = (Button) findViewById(R.id.btnCancel);
				} catch (Exception e) {
					// TODO: we really need to think about our exception handling
					// approach
					e.printStackTrace();
				}
			}

			private void updateFieldsFromReminder(Reminder reminder) throws Exception {
				edtReminder.setText(reminder.getText());
				edtDetails.setText(reminder.getDetails());
				edtDate.setText(reminder.getDate());
				edtHour.setText(reminder.getHour());
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.Calendar;
		import java.util.GregorianCalendar;
		import java.util.List;

		import android.content.Context;
		import android.graphics.Color;
		import android.graphics.Typeface;
		import android.view.LayoutInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.CheckBox;
		import android.widget.CompoundButton;
		import android.widget.ImageView;
		import android.widget.LinearLayout;
		import android.widget.TextView;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;

		public class ReminderArrayAdapter extends ArrayAdapter<Reminder> {

			private Context context;

			private int rowColor = Color.BLACK;// Used to change the row texts color

			// rowType: used to identify which type of row it might produce, once
			// that each one has a different way to show the Date, for example.
			private int rowType = NEXT_DAYS;

			// Type constants:
			public static final int LATE = 0;
			public static final int TODAY = 1;
			public static final int NEXT_DAYS = 2;
			public static final int NO_DATE = 3;

			/**
			 * This class is used in the parts of the view which is needed to list the
			 * reminders, as an adapter to these components listing the Reminders items.
			 *
			 * @param context
			 *            , and the reminders objects(List<Reminders>).
			 *
			 * @author positivo
			 *
			 */
			public ReminderArrayAdapter(Context context, List<Reminder> objects) {
				super(context, R.layout.reminder_row, objects);
				this.context = context;

				this.rowColor = Color.BLACK;
				this.rowType = NEXT_DAYS;
			}

			public ReminderArrayAdapter(Context context, List<Reminder> objects, int rowColor, int rowType) {
				super(context, R.layout.reminder_row, objects);
				this.context = context;

				this.rowColor = rowColor;
				this.rowType = rowType;
			}

			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout reminderRow;

				// Inflate the row view
				if (convertView == null) {
					reminderRow = new LinearLayout(getContext());
					String inflater = Context.LAYOUT_INFLATER_SERVICE;
					LayoutInflater vi;
					vi = (LayoutInflater) getContext().getSystemService(inflater);
					vi.inflate(R.layout.reminder_row, reminderRow, true);
				} else {
					reminderRow = (LinearLayout) convertView;
				}

				// Takes the views included in the row
				TextView tvReminder = (TextView) reminderRow.findViewById(R.id.txtReminder);
				TextView tvDateFirst = (TextView) reminderRow.findViewById(R.id.txtDateFirst);
				TextView tvDateSecond = (TextView) reminderRow.findViewById(R.id.txtDateSecond);
				CheckBox tvDone = (CheckBox) reminderRow.findViewById(R.id.cbDone);
				tvDone.setTag(position);
				tvDone.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
					public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
						try {
							Reminder reminder = getItem((Integer) buttonView.getTag());
							reminder.setDone(isChecked);
							Controller.instance(getContext()).updateReminder(reminder);
						} catch (DBException e) {
							e.printStackTrace();
						}
					}
				});

				tvReminder.setTextColor(rowColor);
				tvReminder.setText(getItem(position).getText());

				// Based in the type of the row includes the specified date
				tvDateFirst.setTextColor(rowColor);
				tvDateFirst.setText(getDateFirst(position));
				tvDateSecond.setTextColor(rowColor);
				tvDateSecond.setText(getDateSecond(position));

				tvDone.setChecked(getItem(position).isDone());

				return reminderRow;
			}

			/**
			 * Used to get the DateFirst based in the rowType and proximity to the
			 * current date.
			 *
			 * @param position
			 * @return
			 */
			private String getDateFirst(int position) {

				if (getItem(position).getDate() == null) {
					return "";
				}

				String months[] = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC" };
				String week[] = { "", "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT" };

				// Today and thatDay Calendars being initialized
				Calendar today = Calendar.getInstance();
				GregorianCalendar thatDay = new GregorianCalendar();
				thatDay.set(Integer.parseInt(getItem(position).getDate().substring(6, 10)), // year
						Integer.parseInt(getItem(position).getDate().substring(3, 5)) - 1, // month
						Integer.parseInt(getItem(position).getDate().substring(0, 2)));// day

				// switch based on the row type
				switch (rowType) {
				case LATE:
					long diff = today.getTimeInMillis() - thatDay.getTimeInMillis();
					long days = diff / (24*60*60*1000);
					if (days == 1)
						return "Yesterday";
					else
						return days + " days ago";
					// break;

				case TODAY:
					return getDatesHour(position);
				// break;

				case NEXT_DAYS:
					diff = thatDay.getTimeInMillis() - today.getTimeInMillis();
					days = diff / (24*60*60*1000);

					if (days == 1) {
						return getDatesHour(position);
					} else if (days < 6) {
						return week[thatDay.get(Calendar.DAY_OF_WEEK)];
					} else {
						return thatDay.get(Calendar.DAY_OF_MONTH) + " " + months[thatDay.get(Calendar.MONTH)];
					}

					// break;

				default:
					break;
				}

				return getItem(position).getDate();

			}

			/**
			 * Used to get the DateSecond based in the rowType
			 *
			 * @param position
			 * @return
			 */
			private String getDateSecond(int position) {

				switch (rowType) {
				case LATE:
					return getDatesHour(position);
				// break;
				case TODAY:
					return "today";
				// break;
				case NEXT_DAYS:
					// Today and thatDay Calendars being initialized
					Calendar today = Calendar.getInstance();
					GregorianCalendar thatDay = new GregorianCalendar();
					thatDay.set(Integer.parseInt(getItem(position).getDate().substring(6, 10)), // year
							Integer.parseInt(getItem(position).getDate().substring(3, 5)) - 1, // month
							Integer.parseInt(getItem(position).getDate().substring(0, 2)));// day

					long diff = thatDay.getTimeInMillis() - today.getTimeInMillis();
					long days = diff / (24*60*60*1000);

					if (days == 1)
						return "tomorrow";
					else
						return getDatesHour(position);
					// break;
				default:
					break;
				}

				return getItem(position).getHour();
			}

			/**
			 * Gets the hour in the DateFirst/DateSecond format
			 *
			 * @param position
			 * @return
			 */
			private String getDatesHour(int position) {

				if (getItem(position).getHour() == null) {
					return "";
				}

				if (getItem(position).getHour().substring(3, 5) != "00")
					return getItem(position).getHour().substring(0, 2) + "h" + getItem(position).getHour().substring(3, 5);
				else
					return getItem(position).getHour().substring(0, 2) + "h";
			}

			/**
			 * Get rowColor
			 *
			 * @return
			 */
			public int getRowColor() {
				return rowColor;
			}

			/**
			 * Set rowColor
			 *
			 * @param rowColor
			 */
			public void setRowColor(int rowColor) {
				this.rowColor = rowColor;
			}

			/**
			 * Get rowType
			 *
			 * @return
			 */
			public int getRowType() {
				return rowType;
			}

			/**
			 * Set rowType
			 *
			 * @param rowType
			 */
			public void setRowType(int rowType) {
				this.rowType = rowType;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.List;

		import android.content.Context;
		import android.view.LayoutInflater;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.ArrayAdapter;
		import android.widget.LinearLayout;
		import android.widget.TextView;
		import br.unb.cic.reminders.controller.ReminderFilter;
		import br.unb.cic.reminders2.R;

		public class ReminderFilterArrayAdapter extends ArrayAdapter<ReminderFilter> {

			/**
			 * This class is used in the parts of the view which is needed to list the
			 * filters, as an adapter to these components listing the ReminderFilter
			 * items.
			 *
			 * @author positivo
			 */

			public ReminderFilterArrayAdapter(Context context, List<ReminderFilter> objects) {
				super(context, R.layout.reminder_row, objects);
			}

			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout filterRow;

				// Inflate the view
				if (convertView == null) {
					filterRow = new LinearLayout(getContext());
					String inflater = Context.LAYOUT_INFLATER_SERVICE;
					LayoutInflater vi;
					vi = (LayoutInflater) getContext().getSystemService(inflater);
					vi.inflate(R.layout.reminder_row, filterRow, true);
				} else {
					filterRow = (LinearLayout) convertView;
				}

				TextView tvReminder = (TextView) filterRow.findViewById(R.id.txtReminder);
				tvReminder.setText(getItem(position).getName());

				return filterRow;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.ArrayList;
		import java.util.Calendar;
		import java.util.GregorianCalendar;
		import java.util.List;

		import util.Utility;
		import android.app.Fragment;
		import android.content.Intent;
		import android.graphics.Color;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.ContextMenu;
		import android.view.ContextMenu.ContextMenuInfo;
		import android.view.MenuInflater;
		import android.view.MenuItem;
		import android.view.View;
		import android.view.ViewGroup;
		import android.widget.AdapterView;
		import android.widget.ListView;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.AllRemindersFilter;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.controller.ReminderFilter;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;

		public class ReminderListFragment extends Fragment implements FiltersListChangeListener {

			private static String TAG = "reminder fragment list";

			private ListView lvReminderLate, lvReminderToday, lvReminderNextDays, lvReminderNoDate;
			private ReminderArrayAdapter adapter;

			// Used to keep the adapter of the listview that called the context menu:
			private ReminderArrayAdapter contextMenuAdapter;

			// Used to reference the interface views to the code in the createUI():
			private View view;

			/**
			 * Called when the activity is first created by the activity.
			 *
			 * @param savedInstanceState
			 *            If the activity is being re-initialized after previously being
			 *            shut down then this Bundle contains the data it most recently
			 *            supplied in onSaveInstanceState(Bundle). <b>Note: Otherwise it
			 *            is null.</b>
			 */
			@Override
			public View onCreateView(android.view.LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				Log.i(TAG, "onCreate");
				view = inflater.inflate(R.layout.reminders_list_fragment, container, false);
				createUI();
				return view;
			}

			/**
			 * onResume method used to update the activity.
			 */
			@Override
			public void onResume() {
				super.onResume();
				updateListView(null);
			}

			/**
			 * Creates the context menu where shows the Edit and Delete options.
			 */
			// @Override
			public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
				super.onCreateContextMenu(menu, v, menuInfo);

				// Save the adapter which created this context menu:
				ListView view = (ListView) v;
				contextMenuAdapter = (ReminderArrayAdapter) view.getAdapter();

				menu.setHeaderTitle(R.string.context_menu_reminder_title);

				MenuInflater inflater = getActivity().getMenuInflater();
				inflater.inflate(R.menu.reminder_list_fragment_context_menu, menu);
			}

			/**
			 * Provides each action based in the chosen option(Edit or Delete).
			 */
			@Override
			public boolean onContextItemSelected(MenuItem item) {
				if (item.getGroupId() == R.id.context_menu_reminder) { // Used to verify
					// if it is the right context_menu

					// Gets the item position and gets the reminder in that position:
					AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
					Reminder reminder = (Reminder) contextMenuAdapter.getItem(info.position);

					// Switch between the options in the context menu(Edit, Delete and
					// Share)
					switch (item.getItemId()) {
					case R.id.edit:
						// Passes the current reminder to be edited via Intent and
						// Invokes edit method
						Intent editIntent = editIntent(reminder);
						editIntent.putExtra("id", reminder.getId());
						editIntent.putExtra("text", reminder.getText());
						editIntent.putExtra("details", reminder.getDetails());
						startActivity(editIntent);
						updateListView(null);
						return true;
					case R.id.delete:
						// Invokes delete method
						try {// Deletes from the bank;
							Controller.instance(getActivity().getApplicationContext()).deleteReminder(reminder);
						} catch (DBException e) {
							Log.e(TAG, e.getMessage());
						}
						updateListView(null);
						return true;
					default:
						return super.onContextItemSelected(item);
					}

				}
				return super.onContextItemSelected(item);
			}

			private Intent editIntent(Reminder reminder) {
				Intent editIntent = new Intent(getActivity().getApplicationContext(), EditReminderActivity.class);
				editIntent.putExtra("date", reminder.getDate());
				editIntent.putExtra("hour", reminder.getHour());
				return editIntent;
			}

			/**
			 * Creates the User Interface.
			 **/
			public void createUI() {
				// Take the ListView view form the layout and apply the
				// ReminderArrayAdapter to it
				lvReminderLate = (ListView) view.findViewById(R.id.lvRemindersLate);
				lvReminderToday = (ListView) view.findViewById(R.id.lvRemindersToday);
				lvReminderNextDays = (ListView) view.findViewById(R.id.lvRemindersNextDays);
				lvReminderNoDate = (ListView) view.findViewById(R.id.lvRemindersNoDate);
				updateListView(null);
				registerForContextMenu(lvReminderLate);
				registerForContextMenu(lvReminderToday);
				registerForContextMenu(lvReminderNextDays);
				registerForContextMenu(lvReminderNoDate);
			}

			/**
			 * Updates the ListView with the current reminders.
			 */
			public void updateListView(ReminderFilter filter) {
				if (filter == null)
					filter = new AllRemindersFilter(getActivity());
				adapter = new ReminderArrayAdapter(getActivity().getApplicationContext(), filter.getReminderList());

				// Divide the adapter in 4 possibilities of dates(Late, Today, Next Days
				// and No Date)
				// and distribute it to each responsible ListView:
				ReminderArrayAdapter adapterLate, adapterToday, adapterNextDays, adapterNoDate;

				Reminder r = new Reminder();
				List<Reminder> remindersLate = new ArrayList<Reminder>();
				List<Reminder> remindersToday = new ArrayList<Reminder>();
				List<Reminder> remindersNextDays = new ArrayList<Reminder>();
				List<Reminder> remindersNoDate = new ArrayList<Reminder>();

				// Runs through the adapter and divides to the correspondent adapter
				for (int i = 0; i < adapter.getCount(); ++i) {
					r = adapter.getItem(i);
					if (r.getDate() != null) {
						String day = r.getDate().substring(0, 2);
						String month = r.getDate().substring(3, 5);
						String year = r.getDate().substring(6, 10);

						Calendar cal = Calendar.getInstance();
						GregorianCalendar gc = new GregorianCalendar();
						if (r.getHour() != null) {
							String hour = r.getHour().substring(0, 2);
							String min = r.getHour().substring(3, 5);
							gc.set(Integer.parseInt(year), Integer.parseInt(month) - 1, Integer.parseInt(day),
									Integer.parseInt(hour), Integer.parseInt(min));
						} else {
							gc.set(Integer.parseInt(year), Integer.parseInt(month) - 1, Integer.parseInt(day));
						}
						// if(Integer.parseInt(day)<cal.get(Calendar.DAY_OF_MONTH))
						if (gc.before(cal))
							remindersLate.add(r);
						else if ((cal.get(Calendar.YEAR) == gc.get(Calendar.YEAR))
								&& (cal.get(Calendar.MONTH) == gc.get(Calendar.MONTH))
								&& (cal.get(Calendar.DAY_OF_MONTH) == gc.get(Calendar.DAY_OF_MONTH)))
							remindersToday.add(r);
						else
							remindersNextDays.add(r);
					} else {
						remindersNoDate.add(r);
					}
				}

				// Creates each adapter:
				adapterLate = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersLate,
						Color.rgb(0xED, 0x1C, 0x24), ReminderArrayAdapter.LATE);
				adapterToday = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersToday,
						Color.rgb(0x33, 0xB5, 0xE5), ReminderArrayAdapter.TODAY);
				adapterNextDays = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersNextDays,
						Color.rgb(0x99, 0x99, 0x99), ReminderArrayAdapter.NEXT_DAYS);
				adapterNoDate = new ReminderArrayAdapter(getActivity().getApplicationContext(), remindersNoDate,
						Color.rgb(0x00, 0x00, 0x00), ReminderArrayAdapter.NO_DATE);

				// Apply the adapters and rearrange the ListViews to its contents size:
				lvReminderLate.setAdapter(adapterLate);
				Utility.setListViewHeightBasedOnChildren(lvReminderLate);
				lvReminderToday.setAdapter(adapterToday);
				Utility.setListViewHeightBasedOnChildren(lvReminderToday);
				lvReminderNextDays.setAdapter(adapterNextDays);
				Utility.setListViewHeightBasedOnChildren(lvReminderNextDays);
				lvReminderNoDate.setAdapter(adapterNoDate);
				Utility.setListViewHeightBasedOnChildren(lvReminderNoDate);
			}

			public void onSelectedFilterChanged(ReminderFilter filter) {
				updateListView(filter);
			}
		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.Iterator;

		import android.content.Context;
		import android.widget.ArrayAdapter;
		import br.unb.cic.reminders2.R;

		public class SpinnerAdapterGenerator<T> {

			public ArrayAdapter<T> getSpinnerAdapter(Iterable<T> items, Context context) {

				// create an empty adapter
				ArrayAdapter<T> adapter = new ArrayAdapter<T>(context.getApplicationContext(), R.layout.spinner_item);
				adapter.setDropDownViewResource(R.layout.spinner_dropdown_item);

				if (items != null && items.iterator().hasNext()) {
					Iterator<T> it = items.iterator();
					while (it.hasNext()) {
						adapter.add(it.next());
					}
				}

				return adapter;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.Calendar;

		import android.app.Dialog;
		import android.app.DialogFragment;
		import android.app.TimePickerDialog;
		import android.content.DialogInterface;
		import android.os.Bundle;
		import android.widget.ArrayAdapter;
		import android.widget.Spinner;
		import android.widget.TimePicker;

		class TimePickerDialogFragment extends DialogFragment implements TimePickerDialog.OnTimeSetListener {

			private Calendar time;

			private Spinner spinnerTime;

			private int pHour;
			private int pMinute;

			public TimePickerDialogFragment(Calendar date, Spinner spinnerTime) {
				this.time = date;
				this.spinnerTime = spinnerTime;
			}

			@Override
			public Dialog onCreateDialog(Bundle savedInstanceState) {
				// Use the current date as the default date in the picker
				int hour = time.get(Calendar.HOUR_OF_DAY);
				int minute = time.get(Calendar.MINUTE);

				// Create a new instance of DatePickerDialog and return it
				return new TimePickerDialog(getActivity(), this, hour, minute, true);
			}

			@SuppressWarnings("unchecked")
			@Override
			public void onDismiss(DialogInterface dialog) {
				time.set(Calendar.MINUTE, pMinute);
				time.set(Calendar.HOUR_OF_DAY, pHour);
				String sTime = Integer.toString(pMinute);
				if (pMinute < 10)
					sTime = "0" + sTime;
				sTime = Integer.toString(pHour) + ":" + sTime;

				ArrayAdapter<String> adapter = (ArrayAdapter<String>) spinnerTime.getAdapter();
				adapter.add(sTime);
				spinnerTime.setSelection(2);

				super.onDismiss(dialog);
			}

			public void onTimeSet(TimePicker view, int hour, int minute) {
				pHour = hour;
				pMinute = minute;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.controller;

		import android.content.Context;
		import br.unb.cic.reminders.model.Reminder;

		public class AllRemindersFilter extends ReminderFilter {

			private final String name = "All";

			public AllRemindersFilter(Context context) {
				super(context);
			}

			@Override
			protected boolean selectReminder(Reminder r) {
				return true;
			}

			@Override
			public String getName() {
				return name;
			}

		}
	}
	adds {
		package br.unb.cic.reminders.controller;

		import java.util.ArrayList;
		import java.util.List;

		import android.content.Context;
		import br.unb.cic.reminders.model.Reminder;

		public abstract class ReminderFilter {

			private List<Reminder> reminders;
			private Context context;

			public ReminderFilter(Context context) {
				this.context = context;
			}

			public List<Reminder> getReminderList() {
				updateReminders();
				return reminders;
			}

			public int getNumReminders() {
				updateReminders();
				return reminders.size();
			}

			private void updateReminders() {
				reminders = new ArrayList<Reminder>();
				List<Reminder> allReminders = null;

				try {
					// Get all reminders
					allReminders = Controller.instance(context).listReminders();
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				// Filter the reminders
				for (Reminder r : allReminders) {
					if (selectReminder(r)) {
						reminders.add(r);
					}
				}
			}

			abstract protected boolean selectReminder(Reminder r);

			abstract public String getName();
		}
	}
	adds {
		package br.unb.cic.reminders.model;

		import java.util.regex.Matcher;
		import java.util.regex.Pattern;

		import util.Patterns;
		import br.unb.cic.framework.persistence.DBTypes;
		import br.unb.cic.framework.persistence.annotations.Column;
		import br.unb.cic.framework.persistence.annotations.Entity;
		import br.unb.cic.framework.persistence.annotations.ForeignKey;
		import br.unb.cic.reminders.view.InvalidHourException;

		/**
		 * This class provides basic representation of a reminder.
		 *
		 * @author rbonifacio
		 */
		@Entity(table = "REMINDER")
		public class Reminder {

			@Column(column = "PK", primaryKey = true, type = DBTypes.LONG)
			private Long id;

			@Column(column = "TEXT", type = DBTypes.TEXT)
			private String text;

			@Column(column = "DETAILS", type = DBTypes.TEXT)
			private String details;

			@Column(column = "DATE", type = DBTypes.TEXT)
			private String date; // it must be in the YYYY-MM-DD format

			@Column(column = "HOUR", type = DBTypes.TEXT)
			private String hour; // it must be in the HH:mm format

			@Column(column = "DONE", type = DBTypes.INT)
			private boolean done;

			public Reminder() {
			}

			public Reminder(Long id, String text) {
				this.id = id;
				this.text = text;
			}

			public Long getId() {
				return id;
			}

			public void setId(Long id) {
				this.id = id;
			}

			public String getText() {
				return text;
			}

			public void setText(String text) {
				if (text == null || text.trim().equals("")) {
					throw new InvalidTextException(text);
				}
				this.text = text;
			}

			public String getDetails() {
				return details;
			}

			public void setDetails(String details) {
				// Details are optional.
				if (details == null || details.trim().equals("")) {
					this.details = null;
				} else {
					this.details = details;
				}
			}

			public String getDate() {
				return date;
			}

			public void setDate(String date) {
				// We allow reminders to have no date associated.
				if (!(date == null || date.equals("")) && !checkFormat(date, Patterns.DATE_PATTERN)) {
					throw new InvalidDateException(date);
				}
				this.date = date;
			}

			public String getHour() {
				return hour;
			}

			public void setHour(String hour) {
				// We allow reminders to have no hour associated.
				if (!(hour == null || hour.equals("")) && !checkFormat(hour, Patterns.HOUR_PATTERN)) {
					throw new InvalidHourException(hour);
				}
				this.hour = hour;
			}

			private boolean checkFormat(String date, String pattern) {
				Pattern p = Pattern.compile(pattern);
				Matcher m = p.matcher(date);
				return m.matches();
			}

			public boolean isValid() {
				return (text != null && date != null && hour != null);
			}

			public boolean isDone() {
				return done;
			}

			public void setDone(boolean done) {
				this.done = done;
			}

			/* DB getter & setter */
			public int getDone() {
				return done ? 1 : 0;
			}

			public void setDone(int done) {
				this.done = (done == 0 ? false : true);
			}

		}
	}
	adds {
		package br.unb.cic.reminders.model.db;

		public class DBConstants {
			public static String DROP_TABLE_STATEMENTS[] = { "DROP TABLE IF EXISTS REMINDER"};

			public static String CREATE_TABLE_STATEMENTS[] = {
					"CREATE TABLE REMINDER ( " + "PK INTEGER PRIMARY KEY AUTOINCREMENT, " + "TEXT VARCHAR(50) NOT NULL,"
							+ "DETAILS VARCHAR(50) NULL," + tableStatement() + "DONE INTEGER NOT NULL);", };

			private static String tableStatement() {
				return "DATE CHAR(10) NULL," + "HOUR CHAR(5) NULL,";
			}

			public static final String SELECT_REMINDERS = "SELECT * FROM REMINDER";

			public static String REMINDER_TABLE = "REMINDER";
			public static String REMINDER_PK_COLUMN = "PK";
			public static String REMINDER_TEXT_COLUMN = "TEXT";
			public static String REMINDER_DETAILS_COLUMN = "DETAILS";
			public static String REMINDER_DATE_COLUMN = "DATE";
			public static String REMINDER_HOUR_COLUMN = "HOUR";
			public static String REMINDER_DONE_COLUMN = "DONE";

		}

	}
	adds {
		package br.unb.cic.reminders.model.db;

		import android.content.Context;

		/**
		 * An abstract factory class to instantiate DAOs.
		 *
		 * @author rbonifacio
		 */
		public abstract class DBFactory {
			protected Context context;

			public static DBFactory factory(Context context) {
				return new DefaultDBFactory(context);
			}

			/**
			 * DBFactory constructor
			 *
			 * @param context
			 *            the application context.
			 */
			public DBFactory(Context context) {
				this.context = context;
			}

			/**
			 * Returns an instance of ReminderDAO.
			 *
			 * @return an instance of ReminderDAO
			 */
			public abstract ReminderDAO createReminderDAO();
		}
	}
	adds {
		package br.unb.cic.reminders.model.db;

		import android.content.Context;

		/**
		 * A default implementation of the abstract class DBFactory.
		 *
		 * @author rbonifacio
		 */
		public class DefaultDBFactory extends DBFactory {

			public DefaultDBFactory(Context context) {
				super(context);
			}

			@Override
			public ReminderDAO createReminderDAO() {
				return new DefaultReminderDAO(context);
			}
		}

	}
	adds {
		package br.unb.cic.reminders.model.cp;

		import android.content.ContentProvider;
		import android.content.ContentValues;
		import android.content.UriMatcher;
		import android.database.Cursor;
		import android.net.Uri;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders.model.db.DBConstants;
		import br.unb.cic.reminders.model.db.DefaultDBFactory;
		import br.unb.cic.reminders.model.db.ReminderDAO;

		/**
		 * A content provider for the Reminders database.
		 *
		 * @author rbonifacio
		 */
		public class ReminderContentProvider extends ContentProvider {

			private static final int REMINDERS = 10;

			private static final String SECURITY_EXCEPTION = "You are not allowed to call this method";

			private static final String AUTHORITY = "br.com.positivo.reminders.contentprovider";
			private static final String BASE_PATH = "reminders";

			public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/" + BASE_PATH);

			public static final String text() {
				return DBConstants.REMINDER_TEXT_COLUMN;
			}

			public static final String date() {
				return DBConstants.REMINDER_DATE_COLUMN;
			}

			public static final String hour() {
				return DBConstants.REMINDER_HOUR_COLUMN;
			}

			private ReminderDAO rdao;

			// this is only relevant in the cases where we want to expose
			// access to more than one database table.
			private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

			static {
				sURIMatcher.addURI(AUTHORITY, BASE_PATH, REMINDERS);
			}

			@Override
			public boolean onCreate() {
				rdao = DefaultDBFactory.factory(getContext()).createReminderDAO();
				return false;
			}

			@Override
			public Uri insert(Uri uri, ContentValues values) {
				try {
					Reminder reminder = createReminderInsert(values);

					reminder.setText(values.getAsString(text()));

					Long id = rdao.saveReminder(reminder);
					getContext().getContentResolver().notifyChange(uri, null);
					return Uri.parse(BASE_PATH + "/" + id);
				} catch (DBException e) {
					throw new RuntimeException(e.getLocalizedMessage());
				}

			}

			private Reminder createReminderInsert(ContentValues values) throws DBException {
				Reminder reminder = new Reminder();
				reminder.setDate(values.getAsString(date()));
				reminder.setHour(values.getAsString(hour()));
				return reminder;
			}

			@Override
			public Cursor query(Uri arg0, String[] arg1, String arg2, String[] arg3, String arg4) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			/**
			 * An external application could not delete an existing reminder.
			 */
			public int delete(Uri arg0, String arg1, String[] arg2) {
				throw new SecurityException(SECURITY_EXCEPTION);
			}

			@Override
			/**
			 * It is not clear the rationale for this method. Most examples just return
			 * null.
			 */
			public String getType(Uri arg0) {
				return null;
			}

			@Override
			/**
			 * Ok, we also do not allow an externa application to update an existing
			 * reminder. A RuntimeException is thrown.
			 */
			public int update(Uri arg0, ContentValues arg1, String arg2, String[] arg3) {
				throw new SecurityException(SECURITY_EXCEPTION);
			}

		}
	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.List;

		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.Reminder;

		public class AddReminderActivity extends ReminderActivity {

			@Override
			protected void initializeValues() {
			}

			@Override
			protected void persist(Reminder reminder) {
				try {
					Controller.instance(getApplicationContext()).addReminder(reminder);
				} catch (DBException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

		}

	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.List;

		import android.content.Intent;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.Reminder;

		public class EditReminderActivity extends ReminderActivity {

			@Override
			protected void initializeValues() {
				Intent intent = getIntent();

				// Gets the information from the intent if it is an edit call
				long reminderId = intent.getLongExtra("id", 0);
				String text = intent.getStringExtra("text");
				String details = intent.getStringExtra("details");

				reminder.setId(reminderId);
				edtReminder.setText(text);
				edtDetails.setText(details);
				try {
					initializeValues(intent);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			private void initializeValues(Intent intent) throws Exception {
				String date = intent.getStringExtra("date");
				String hour = intent.getStringExtra("hour");
				updateSpinnerDateHour(spinnerDate, date);
				updateDateFromString(date);
				updateSpinnerDateHour(spinnerTime, hour);
				updateTimeFromString(hour);
			}

			@Override
			protected void persist(Reminder reminder) {
				try {
					Controller.instance(getApplicationContext()).updateReminder(reminder);
				} catch (DBException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}

	}
	adds {
		package br.unb.cic.reminders.view;

		import java.util.List;

		import android.content.Intent;
		import android.os.Bundle;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.Reminder;

		public class ExternalAddReminderActivity extends ReminderActivity {

			@Override
			protected void onCreate(Bundle savedInstanceState) {
				reminder = new Reminder();
				try {
					setReminderFromIntent();
				} catch (Exception e) {
					Intent intent2 = new Intent(getApplicationContext(), AddReminderActivity.class);
					startActivity(intent2);
					finish();
				}
				super.onCreate(savedInstanceState);
			}

			private void setReminderFromIntent() throws Exception {
				Intent intent = getIntent();
				String action = intent.getAction();
				String type = intent.getType();

				// Gets the information from the intent if it is an edit call
				if (action.equals("br.com.positivo.reminders.ADD_REMINDER") && "text/plain".equals(type)) {
					String text = intent.getStringExtra("text");
					String details = intent.getStringExtra("details");

					reminder.setText(text);
					reminder.setDetails(details);
					reminderFromIntent(intent);
				} else
					reminder = null;

			}

			private void reminderFromIntent(Intent intent) throws Exception {
				String date = intent.getStringExtra("date");
				String hour = intent.getStringExtra("hour");
				reminder.setDate(date);
				reminder.setHour(hour);
			}

			@Override
			protected void initializeValues() {

				if (!reminder.isValid())
					return;

				edtReminder.setText(reminder.getText());
				edtDetails.setText(reminder.getDetails());
				try {
					initialize();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

			private void initialize() throws Exception {
				updateSpinnerDateHour(spinnerDate, reminder.getDate());
				updateDateFromString(reminder.getDate());
				updateSpinnerDateHour(spinnerTime, reminder.getHour());
				updateTimeFromString(reminder.getHour());
			}

			@Override
			protected void persist(Reminder reminder) {
				try {
					Controller.instance(getApplicationContext()).addReminder(reminder);
				} catch (DBException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

		}

	}
	adds {
		package br.unb.cic.reminders.view;

		import java.text.ParseException;
		import java.util.ArrayList;
		import java.util.Arrays;
		import java.util.Calendar;
		import java.util.List;

		import android.app.Activity;
		import android.app.DialogFragment;
		import android.os.Bundle;
		import android.util.Log;
		import android.view.KeyEvent;
		import android.view.MotionEvent;
		import android.view.View;
		import android.widget.AdapterView;
		import android.widget.AdapterView.OnItemSelectedListener;
		import android.widget.ArrayAdapter;
		import android.widget.Button;
		import android.widget.CheckBox;
		import android.widget.EditText;
		import android.widget.Spinner;
		import android.widget.Toast;
		import br.unb.cic.reminders.controller.Controller;
		import br.unb.cic.reminders.model.InvalidDateException;
		import br.unb.cic.reminders.model.InvalidTextException;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders2.R;

		public abstract class ReminderActivity extends Activity {

			protected Reminder reminder;
			protected Calendar date, time;

			protected EditText edtReminder, edtDetails, edtDate, edtTime;
			protected Spinner spinnerDate, spinnerTime;
			private Button btnSave, btnCancel;

			// TODO: Rename XML from reminder_add to reminder_form.

			@Override
			protected void onCreate(Bundle savedInstanceState) {
				super.onCreate(savedInstanceState);
				setContentView(R.layout.reminder_add);

				if (reminder == null)
					reminder = new Reminder();
				initializeFields();
				initializeListeners();
				initializeValues();
			}

			private void initializeFields() {
				btnSave = (Button) findViewById(R.id.btnSave);
				btnCancel = (Button) findViewById(R.id.btnCancel);
				edtReminder = (EditText) findViewById(R.id.edtReminder);
				edtDetails = (EditText) findViewById(R.id.edtDetails);
				spinnerDate = getSpinnerDate();
				spinnerTime = getSpinnerTime();
				// edtDate = (EditText) findViewById(R.id.selectedDate);
				// edtTime = (EditText) findViewById(R.id.selectedTime);

			}

			private void initializeListeners() {
				addListenerToBtnSave();
				addListenerToBtnCancel();
				addListenerToSpinnerDate();
				addListenerToSpinnerTime();
			}

			protected abstract void initializeValues();

			private void addListenerToBtnSave() {
				btnSave.setOnClickListener(new Button.OnClickListener() {
					public void onClick(View v) {
						try {
							createReminder();
							persist(reminder);
							finish();
						} catch (Exception e) {
							Log.e("ReminderActivity", e.getMessage());
							e.printStackTrace();
						}
					}

				});
			}

			private void addListenerToBtnCancel() {
				btnCancel.setOnClickListener(new Button.OnClickListener() {
					public void onClick(View v) {
						finish();
					}
				});
			}

			private void addListenerToSpinnerDate() {

				/* DO NOT DELETE THESE COMMENTS! (Alexandre) */
				/*
				 * They work and give a different behaviour to the spinner! Maybe we
				 * need this for the next sprint, depending on the Designer.
				 */
				// spinnerDate.setOnTouchListener(new View.OnTouchListener() {
				// @SuppressWarnings("unchecked")
				// public boolean onTouch(View v, MotionEvent event) {
				// if(spinnerDate.getAdapter().getCount() > 2) {
				// spinnerDate.setTag((String) spinnerDate.getSelectedItem());
				// ArrayAdapter<String> adapter = (ArrayAdapter<String>)
				// spinnerDate.getAdapter();
				// adapter.remove((String) spinnerDate.getSelectedItem());
				// spinnerDate.setSelection(0);
				// }
				// return false;
				// }
				// });
				//
				// spinnerDate.setOnKeyListener(new View.OnKeyListener() {
				// @SuppressWarnings("unchecked")
				// public boolean onKey(View v, int keyCode, KeyEvent event) {
				// if(spinnerDate.getAdapter().getCount() > 2) {
				// spinnerDate.setTag((String) spinnerDate.getSelectedItem());
				// ArrayAdapter<String> adapter = (ArrayAdapter<String>)
				// spinnerDate.getAdapter();
				// adapter.remove((String) spinnerDate.getSelectedItem());
				// spinnerDate.setSelection(0);
				// }
				// return false;
				// }
				// });

				spinnerDate.setOnTouchListener(new View.OnTouchListener() {
					public boolean onTouch(View v, MotionEvent event) {
						spinnerDate = getSpinnerDate();
						return false;
					}
				});

				spinnerDate.setOnKeyListener(new View.OnKeyListener() {
					public boolean onKey(View v, int keyCode, KeyEvent event) {
						spinnerDate = getSpinnerDate();
						return false;
					}
				});

				spinnerDate.setOnItemSelectedListener(new OnItemSelectedListener() {

					public void onItemSelected(AdapterView<? extends Object> parent, View view, int pos, long id) {

						switch (pos) {
						case 0:
							date = null;
							break;
						case 1:
							if (date == null)
								date = Calendar.getInstance();
							DialogFragment newFragment = new DatePickerDialogFragment(date, spinnerDate);
							newFragment.show(getFragmentManager(), "datePicker");
							break;
						default:
						}
					}

					public void onNothingSelected(AdapterView<? extends Object> arg0) {
						// Well, do nothing...
					}

				});
			}

			private void addListenerToSpinnerTime() {

				spinnerTime.setOnTouchListener(new View.OnTouchListener() {
					public boolean onTouch(View v, MotionEvent event) {
						spinnerTime = getSpinnerTime();
						return false;
					}
				});

				spinnerTime.setOnKeyListener(new View.OnKeyListener() {
					public boolean onKey(View v, int keyCode, KeyEvent event) {
						spinnerTime = getSpinnerTime();
						return false;
					}
				});

				spinnerTime.setOnItemSelectedListener(new OnItemSelectedListener() {

					public void onItemSelected(AdapterView<? extends Object> parent, View view, int pos, long id) {

						switch (pos) {
						case 0:
							time = null;
							break;
						case 1:
							if (time == null)
								time = Calendar.getInstance();
							DialogFragment newFragment = new TimePickerDialogFragment(time, spinnerTime);
							newFragment.show(getFragmentManager(), "timePicker");
							break;
						default:
						}
					}

					public void onNothingSelected(AdapterView<? extends Object> arg0) {
						// Well, do nothing...
					}

				});

			}

			/**
			 * Just an auxiliary method to create reminders from the UI data.
			 *
			 * @return a new reminder with the ui values.
			 **/
			private void createReminder() {
				try {
					reminder.setText(edtReminder.getText().toString());
					reminder.setDetails(edtDetails.getText().toString());
					setValuesOnReminder();
				} catch (InvalidTextException e) {
					// This catch is handling both Reminder's Text and Details.
					Toast.makeText(getApplicationContext(), "Invalid text.", Toast.LENGTH_SHORT).show();
				} catch (InvalidDateException e) {
					Toast.makeText(getApplicationContext(), "Invalid date.", Toast.LENGTH_SHORT).show();
				} catch (InvalidHourException e) {
					Toast.makeText(getApplicationContext(), "Invalid time.", Toast.LENGTH_SHORT).show();
				} catch (Exception e) {
					// this is an exceptional case that needs to be studied
					Toast.makeText(getApplicationContext(), "Serious error.", Toast.LENGTH_SHORT).show();
				}
			}

			private void setValuesOnReminder() throws Exception {
				reminder.setDate(dateToString());
				reminder.setHour(timeToString());
			}

			private String dateToString() {
				if (date == null)
					return null;
				String sDate;
				sDate = Integer.toString(date.get(Calendar.MONTH) + 1);
				if (date.get(Calendar.MONTH) + 1 < 10)
					sDate = "0" + sDate;
				sDate = Integer.toString(date.get(Calendar.DAY_OF_MONTH)) + "-" + sDate;
				if (date.get(Calendar.DAY_OF_MONTH) < 10)
					sDate = "0" + sDate;
				sDate += "-" + Integer.toString(date.get(Calendar.YEAR));
				return sDate;
			}

			private String timeToString() {
				if (time == null)
					return null;
				String sTime;
				sTime = Integer.toString(time.get(Calendar.MINUTE));
				if (time.get(Calendar.MINUTE) < 10)
					sTime = "0" + sTime;
				sTime = Integer.toString(time.get(Calendar.HOUR_OF_DAY)) + ":" + sTime;
				if (time.get(Calendar.HOUR_OF_DAY) < 10)
					sTime = "0" + sTime;
				return sTime;
			}

			protected void updateDateFromString(String sDate) {
				if (sDate == null || sDate.equals("")) {
					date = null;
					return;
				}
				char sDay[] = { sDate.charAt(0), sDate.charAt(1) };
				int day = Integer.parseInt(new String(sDay), 10);
				char sMonth[] = { sDate.charAt(3), sDate.charAt(4) };
				int month = Integer.parseInt(new String(sMonth), 10);
				char sYear[] = { sDate.charAt(6), sDate.charAt(7), sDate.charAt(8), sDate.charAt(9) };
				int year = Integer.parseInt(new String(sYear), 10);
				if (date == null)
					date = Calendar.getInstance();
				date.set(year, month - 1, day);
			}

			protected void updateTimeFromString(String sTime) {
				if (sTime == null || sTime.equals("")) {
					time = null;
					return;
				}
				char sHour[] = { sTime.charAt(0), sTime.charAt(1) };
				int hour = Integer.parseInt(new String(sHour), 10);
				char sMinute[] = { sTime.charAt(3), sTime.charAt(4) };
				int minute = Integer.parseInt(new String(sMinute), 10);
				if (time == null)
					time = Calendar.getInstance();
				time.set(Calendar.MINUTE, minute);
				time.set(Calendar.HOUR_OF_DAY, hour);
			}

			/*
			 * Utility method which inserts a new date into the last position of the
			 * spinner.
			 */
			@SuppressWarnings("unchecked")
			protected void updateSpinnerDateHour(Spinner spinner, String dateOrHour) {
				if (dateOrHour == null)
					return;

				ArrayAdapter<String> adapter = (ArrayAdapter<String>) spinner.getAdapter();

				int count = adapter.getCount();
				if (count > 2) {
					for (int i = 2; i < count; ++i)
						// Date and Time Spinners can have max of 3 elements.
						adapter.remove(adapter.getItem(i));
				}
				adapter.add(dateOrHour);
				spinner.setSelection(2);
			}

			private Spinner getSpinnerDate() {
				Spinner spinner = (Spinner) findViewById(R.id.spinnerDate);

				SpinnerAdapterGenerator<String> adapterDateGenerator = new SpinnerAdapterGenerator<String>();

				List<String> items = new ArrayList<String>();
				// TODO: Move these to XML.
				items.add("No date");
				items.add("+ Select");

				spinner.setAdapter(adapterDateGenerator.getSpinnerAdapter(items, this));

				return spinner;
			}

			private Spinner getSpinnerTime() {
				Spinner spinner = (Spinner) findViewById(R.id.spinnerTime);

				SpinnerAdapterGenerator<String> adapterTimeGenerator = new SpinnerAdapterGenerator<String>();

				List<String> items = new ArrayList<String>();
				// TODO: Move these to XML.
				items.add("No time");
				items.add("+ Select");

				spinner.setAdapter(adapterTimeGenerator.getSpinnerAdapter(items, this));

				return spinner;
			}

			protected abstract void persist(Reminder reminder);

		}

	}
	adds {
		package br.unb.cic.reminders.controller;

		import java.util.List;

		import android.content.Context;
		import br.unb.cic.framework.persistence.DBException;
		import br.unb.cic.reminders.model.Reminder;
		import br.unb.cic.reminders.model.db.DBFactory;

		/**
		 * Class that is responsible for handling user inputs and processing the
		 * business rules of the system. Nevertheless, it is important to note that the
		 * business rules in this system are really, really simple. For this reason, a
		 * single controller might be enough.
		 *
		 * @author rbonifacio
		 *
		 */
		public class Controller {

			private Context context;

			private static Controller instance;

			/*
			 * Private constructor, according to the singleton design pattern.
			 */
			private Controller(Context c) {
				this.context = c;
			}

			/**
			 * The single interface to obtain an instance of the Controller class,
			 * according to the singleton pattern.
			 */
			public static final Controller instance(Context c) {
				if (instance == null) {
					instance = new Controller(c);
				}

				return instance;
			}

			/**
			 * Return all reminders
			 */
			public List<Reminder> listReminders() throws Exception {
				try {
					return DBFactory.factory(context).createReminderDAO().listReminders();
				} catch (DBException e) {
					// TODO: we need to define what to do in these situations.
					throw e;
				}
			}

			/**
			 * Add a new reminder to the list of existing reminders
			 */
			public void addReminder(Reminder reminder) throws DBException {
				try {
					DBFactory.factory(context).createReminderDAO().saveReminder(reminder);
				} catch (DBException e) {
					// TODO: we need to define what to do in these situations.
					throw e;
				}
			}

			/**
			 * Add a new reminder to the list of existing reminders
			 */
			public void updateReminder(Reminder reminder) throws DBException {
				try {
					DBFactory.factory(context).createReminderDAO().updateReminder(reminder);
				} catch (DBException e) {
					// TODO: we need to define what to do in these situations.
					throw e;
				}
			}

			/**
			 * Remove a reminder given a Reminder object
			 */
			public void deleteReminder(Reminder reminder) throws DBException {
				try {
					DBFactory.factory(context).createReminderDAO().deleteReminder(reminder);
				} catch (DBException e) {
					// TODO: we need to define what to do in these situations.
					throw e;
				}
			}

			/**
			 * Persist a reminder given a Reminder object
			 */
			public void persistReminder(Reminder reminder) throws DBException {
				try {
					DBFactory.factory(context).createReminderDAO().persistReminder(reminder);
				} catch (DBException e) {
					// TODO: we need to define what to do in these situations.
					throw e;
				}
			}

			/*
			 * throws a RunTimeException
			 *
			 * TODO: remove this method after all other public methods would have been
			 * implemented.
			 */
			private void notImplementedYet() {
				throw new RuntimeException("not implemented yet");
			}
		}

	}
}
